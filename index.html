<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Maze Game</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: #000;
}
#ui {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: #00ffff;
  font-family: monospace;
  font-size: 14px;
  z-index: 10;
}
</style>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
</head>

<body>
<div id="ui">Level: <span id="level">1</span> | WASD Move | Mouse = Camera</div>

<script>
/* ================= BASIC SETUP ================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x05050a);

const camera = new THREE.PerspectiveCamera(
  70, window.innerWidth / window.innerHeight, 0.1, 1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

/* ================= LIGHT ================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(20, 30, 10);
sun.castShadow = true;
scene.add(sun);

/* ================= GAME STATE ================= */
let level = 1;
let mazeSize = 7;
let maze = [];
let walls = [];

/* ================= PLAYER ================= */
const player = new THREE.Mesh(
  new THREE.BoxGeometry(0.6, 0.6, 0.6),
  new THREE.MeshStandardMaterial({ color: 0x00ffff })
);
player.castShadow = true;
scene.add(player);

/* ================= GOAL ================= */
const goal = new THREE.Mesh(
  new THREE.BoxGeometry(0.6, 0.2, 0.6),
  new THREE.MeshStandardMaterial({ color: 0x00ff66 })
);
scene.add(goal);

/* ================= FLOOR ================= */
const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

/* ================= MAZE GENERATION ================= */
function generateMaze(size) {
  maze = [];
  for (let z = 0; z < size; z++) {
    maze[z] = [];
    for (let x = 0; x < size; x++) {
      maze[z][x] = Math.random() > 0.7 ? 1 : 0;
    }
  }
  maze[0][0] = 0;
  maze[size - 1][size - 1] = 0;
}

function buildMaze() {
  walls.forEach(w => scene.remove(w));
  walls = [];

  const half = mazeSize / 2;

  for (let z = 0; z < mazeSize; z++) {
    for (let x = 0; x < mazeSize; x++) {
      if (maze[z][x] === 1) {
        const wall = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshStandardMaterial({ color: 0x3333ff })
        );
        wall.position.set(x - half, 0.5, z - half);
        wall.castShadow = true;
        scene.add(wall);
        walls.push(wall);
      }
    }
  }

  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(mazeSize, mazeSize),
    floorMat
  );
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);
}

/* ================= START LEVEL ================= */
function startLevel() {
  document.getElementById("level").textContent = level;
  generateMaze(mazeSize);
  buildMaze();

  player.position.set(-mazeSize / 2, 0.3, -mazeSize / 2);
  goal.position.set(
    mazeSize / 2 - 1,
    0.1,
    mazeSize / 2 - 1
  );

  camera.position.set(0, mazeSize, mazeSize);
  camera.lookAt(0, 0, 0);
}

startLevel();

/* ================= CONTROLS ================= */
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

let mouseX = 0;
window.addEventListener("mousemove", e => {
  mouseX = (e.clientX / window.innerWidth - 0.5) * 2;
});

/* ================= GAME LOOP ================= */
function animate() {
  requestAnimationFrame(animate);

  const speed = 0.08;
  const oldPos = player.position.clone();

  if (keys["w"]) player.position.z -= speed;
  if (keys["s"]) player.position.z += speed;
  if (keys["a"]) player.position.x -= speed;
  if (keys["d"]) player.position.x += speed;

  // Wall collision
  for (const w of walls) {
    if (player.position.distanceTo(w.position) < 0.7) {
      player.position.copy(oldPos);
      break;
    }
  }

  // Camera control
  camera.position.x = Math.sin(mouseX) * mazeSize;
  camera.position.z = Math.cos(mouseX) * mazeSize;
  camera.lookAt(player.position);

  // Win condition
  if (player.position.distanceTo(goal.position) < 0.6) {
    level++;
    mazeSize += 2;
    startLevel();
  }

  renderer.render(scene, camera);
}

animate();

/* ================= RESIZE ================= */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
